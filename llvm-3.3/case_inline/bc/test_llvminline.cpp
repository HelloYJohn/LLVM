// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/Pass.h>
#include <llvm/PassManager.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/Assembly/PrintModulePass.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <llvm/Pass.h>
#include <llvm/PassManager.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/Assembly/PrintModulePass.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <algorithm>

#include <llvm/ExecutionEngine/ExecutionEngine.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/ExecutionEngine/JIT.h>
#include "llvm/Support/ManagedStatic.h"

#include <llvm/Pass.h>
#include <llvm/PassManager.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/Assembly/PrintModulePass.h>

#include "llvm/Transforms/IPO.h"
#include <llvm/Transforms/IPO/PassManagerBuilder.h>
#include <iostream>
#include <string>
#include <llvm/ExecutionEngine/GenericValue.h>
#include "llvm/ExecutionEngine/Interpreter.h"
#include "llvm/Support/raw_ostream.h"
#include <llvm/Bitcode/ReaderWriter.h>
#include <llvm-c/BitWriter.h>
#include "static_library.h"
using namespace llvm;

static Module* mod;
static ExecutionEngine* EE;
void makeLLVMModule();
typedef int (*funcPtr)(int a, int b);
int num1[100000000] = {1, 2, 4, 5, 6};
int num2[100000000] = {1, 2, 4, 5, 6};

int main(int argc, char**argv) {
    mod = new Module("Test_Module", getGlobalContext());
    llvm_start_multithreaded();
    InitializeNativeTarget();

    std::string error_code ;

    EngineBuilder eb = EngineBuilder(mod);
    eb.setOptLevel(llvm::CodeGenOpt::Aggressive);
    eb.setEngineKind(EngineKind::JIT);  
    eb.setErrorStr(&error_code);
    EE = eb.create();
    makeLLVMModule();

    verifyModule(*mod, PrintMessageAction);
    PassManager PM;
    PM.add(createAlwaysInlinerPass());
    mod->dump();

    const char* path = "hello_inline.ll";
    std::string ErrorInfo; 
    llvm::raw_fd_ostream OS(path, ErrorInfo);
    WriteBitcodeToFile(mod, OS);
    OS.flush();

    Function* func = NULL ;
    func =  mod->getFunction("_Z4callii");
    if( func == NULL)
    {
        std::cout<< "get function error.." << std::endl;
        return 0;
    }
    int ret = 0;
    void* jitAddr = EE->getPointerToFunction(func);
    funcPtr jitFunc = reinterpret_cast<funcPtr>(jitAddr); // cast to our original signature  
    for (int i = 0; i < 100000000; ++i)
        jitFunc(num1[i], num2[i]);
    // std::cout << jitFunc(1, 2) << std::endl; // call the function  

    return 0;
}

void makeLLVMModule() {
    // Module Construction
    mod->setDataLayout("e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128");
    mod->setTargetTriple("x86_64-unknown-linux-gnu");

    // Type Definitions
    std::vector<Type*>FuncTy_0_args;
    FuncTy_0_args.push_back(IntegerType::get(mod->getContext(), 32));
    FuncTy_0_args.push_back(IntegerType::get(mod->getContext(), 32));
    FunctionType* FuncTy_0 = FunctionType::get(
            /*Result=*/IntegerType::get(mod->getContext(), 32),
            /*Params=*/FuncTy_0_args,
            /*isVarArg=*/false);

    PointerType* PointerTy_1 = PointerType::get(IntegerType::get(mod->getContext(), 32), 0);

    PointerType* PointerTy_2 = PointerType::get(FuncTy_0, 0);


    // Function Declarations

    Function* func__Z4callii = mod->getFunction("_Z4callii");
    if (!func__Z4callii) {
        func__Z4callii = Function::Create(
                /*Type=*/FuncTy_0,
                /*Linkage=*/GlobalValue::ExternalLinkage,
                /*Name=*/"_Z4callii", mod); 
        func__Z4callii->setCallingConv(CallingConv::C);
    }
    AttributeSet func__Z4callii_PAL;
    {
        SmallVector<AttributeSet, 4> Attrs;
        AttributeSet PAS;
        {
            AttrBuilder B;
            B.addAttribute(Attribute::UWTable);
            PAS = AttributeSet::get(mod->getContext(), ~0U, B);
        }

        Attrs.push_back(PAS);
        func__Z4callii_PAL = AttributeSet::get(mod->getContext(), Attrs);

    }
    func__Z4callii->setAttributes(func__Z4callii_PAL);

    Function* func__Z4testii = mod->getFunction("_Z4testii");
    if (!func__Z4testii) {
        func__Z4testii = Function::Create(
                /*Type=*/FuncTy_0,
                /*Linkage=*/GlobalValue::ExternalLinkage,
                /*Name=*/"_Z4testii", mod); // (external, no body)
        func__Z4testii->setCallingConv(CallingConv::C);
    }
    AttributeSet func__Z4testii_PAL;
    {
        SmallVector<AttributeSet, 4> Attrs;
        AttributeSet PAS;
        {
            AttrBuilder B;
            PAS = AttributeSet::get(mod->getContext(), ~0U, B);
        }

        Attrs.push_back(PAS);
        func__Z4testii_PAL = AttributeSet::get(mod->getContext(), Attrs);

    }
    func__Z4testii->setAttributes(func__Z4testii_PAL);
    func__Z4testii->addAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::AlwaysInline);


    // Global Variable Declarations


    // Constant Definitions
    ConstantInt* const_int32_3 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));

    // Global Variable Definitions

    // Function Definitions

    // Function: _Z4callii (func__Z4callii)
    {
        Function::arg_iterator args = func__Z4callii->arg_begin();
        Value* int32_a = args++;
        int32_a->setName("a");
        Value* int32_b = args++;
        int32_b->setName("b");

        BasicBlock* label_entry = BasicBlock::Create(mod->getContext(), "entry",func__Z4callii,0);

        // Block entry (label_entry)
        AllocaInst* ptr_a_addr = new AllocaInst(IntegerType::get(mod->getContext(), 32), "a.addr", label_entry);
        ptr_a_addr->setAlignment(4);
        AllocaInst* ptr_b_addr = new AllocaInst(IntegerType::get(mod->getContext(), 32), "b.addr", label_entry);
        ptr_b_addr->setAlignment(4);
        StoreInst* void_4 = new StoreInst(int32_a, ptr_a_addr, false, label_entry);
        void_4->setAlignment(4);
        StoreInst* void_5 = new StoreInst(int32_b, ptr_b_addr, false, label_entry);
        void_5->setAlignment(4);
        LoadInst* int32_6 = new LoadInst(ptr_a_addr, "", false, label_entry);
        int32_6->setAlignment(4);
        LoadInst* int32_7 = new LoadInst(ptr_b_addr, "", false, label_entry);
        int32_7->setAlignment(4);
        std::vector<Value*> int32_call_params;
        int32_call_params.push_back(int32_6);
        int32_call_params.push_back(int32_7);
        CallInst* int32_call = CallInst::Create(func__Z4testii, int32_call_params, "call", label_entry);
        int32_call->setCallingConv(CallingConv::C);
        int32_call->setTailCall(false);
        AttributeSet int32_call_PAL;
        int32_call->setAttributes(int32_call_PAL);

        ReturnInst::Create(mod->getContext(), int32_call, label_entry);

    }
}
